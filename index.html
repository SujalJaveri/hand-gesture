<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My 3D AI Mirror</title>
    <style>
        body { margin: 0; background-color: #222; overflow: hidden; }
        .input_video { display: none; } /* Hide the raw webcam video */
        .output_canvas { width: 100%; height: 100vh; display: block; } /* 3D Canvas fills the screen */
        /* Loading overlay */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; font-size: 24px; pointer-events: none;
        }
    </style>
</head>
<body>
    <video class="input_video" playsinline></video>
    <canvas class="output_canvas"></canvas>
    <div id="loading">Loading AI & Model...</div>

    <!-- Import Libraries via CDN -->
    <script type="module">
        import * as THREE from 'cdn.skypack.dev';
        import { GLTFLoader } from 'cdn.skypack.dev/examples/jsm/loaders/GLTFLoader.js';
        import { OrbitControls } from 'cdn.skypack.dev/examples/jsm/controls/OrbitControls.js';
        import * as Kalidokit from 'cdn.jsdelivr.net';

        // --- SETUP THREE.JS SCENE ---
        const canvas = document.querySelector('.output_canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.5, 2);

        const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(0, 10, 10);
        scene.add(dirLight);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.update();

        // --- LOAD 3D MODEL ---
        window.bones = {}; // Attach bones to window for global access

        const loader = new GLTFLoader();
        loader.load('model.glb', (gltf) => {
            const model = gltf.scene;
            scene.add(model);
            
            // Map bones by name (adjust includes based on your model's naming)
            model.traverse((object) => {
                if (object.isBone) {
                    const name = object.name.toLowerCase();
                    if (name.includes('neck')) window.bones.Neck = object;
                    if (name.includes('head')) window.bones.Head = object;
                    if (name.includes('hips')) window.bones.Hips = object;
                    if (name.includes('spine')) window.bones.Spine = object;
                    if (name.includes('rightarm') || name.includes('rightupperarm')) window.bones.RightUpperArm = object;
                    if (name.includes('rightforearm') || name.includes('rightlowerarm')) window.bones.RightLowerArm = object;
                    if (name.includes('righthand')) window.bones.RightHand = object;
                    if (name.includes('leftarm') || name.includes('leftupperarm')) window.bones.LeftUpperArm = object;
                    if (name.includes('leftforearm') || name.includes('leftlowerarm')) window.bones.LeftLowerArm = object;
                    if (name.includes('lefthand')) window.bones.LeftHand = object;
                    if (name.includes('rightupleg') || name.includes('rightupperleg')) window.bones.RightUpperLeg = object;
                    if (name.includes('rightleg') || name.includes('rightlowerleg')) window.bones.RightLowerLeg = object;
                    if (name.includes('leftupleg') || name.includes('leftupperleg')) window.bones.LeftUpperLeg = object;
                    if (name.includes('leftleg') || name.includes('leftlowerleg')) window.bones.LeftLowerLeg = object;
                }
            });
            document.getElementById('loading').innerText = "Model Loaded. Starting Camera...";
        }, undefined, (error) => {
            console.error(error);
            document.getElementById('loading').innerText = "Error loading model.glb";
        });

        // --- ANIMATION & TRACKING LOGIC ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Helper to apply rotation
        const rotateBone = (boneName, rotation) => {
            const bone = window.bones[boneName];
            if (bone && rotation) {
                const euler = new THREE.Euler(rotation.x, rotation.y, rotation.z);
                bone.quaternion.setFromEuler(euler);
            }
        };

        // Listen for MediaPipe Results (defined below in global script)
        window.addEventListener('mediapipe-results', (evt) => {
            const results = evt.detail;
            if (!results.poseLandmarks || !window.bones.Hips) return;

            // Solve Pose
            const riggedPose = Kalidokit.Pose.solve(results.poseLandmarks, results.poseLandmarks3D, {
                runtime: 'mediapipe',
                imageSize: { width: 640, height: 480 }
            });

            if (riggedPose) {
                rotateBone('Head', riggedPose.Head);
                rotateBone('Neck', riggedPose.Neck);
                rotateBone('Spine', riggedPose.Spine);
                rotateBone('Hips', riggedPose.Hips);
                rotateBone('RightUpperArm', riggedPose.RightUpperArm);
                rotateBone('RightLowerArm', riggedPose.RightLowerArm);
                rotateBone('LeftUpperArm', riggedPose.LeftUpperArm);
                rotateBone('LeftLowerArm', riggedPose.LeftLowerArm);
                rotateBone('RightUpperLeg', riggedPose.RightUpperLeg);
                rotateBone('RightLowerLeg', riggedPose.RightLowerLeg);
                rotateBone('LeftUpperLeg', riggedPose.LeftUpperLeg);
                rotateBone('LeftLowerLeg', riggedPose.LeftLowerLeg);
            }
            
            // Solve Hands
            if (results.rightHandLandmarks) {
                const riggedHand = Kalidokit.Hand.solve(results.rightHandLandmarks, "Right");
                rotateBone('RightHand', riggedHand.RightWrist);
            }
            if (results.leftHandLandmarks) {
                const riggedHand = Kalidokit.Hand.solve(results.leftHandLandmarks, "Left");
                rotateBone('LeftHand', riggedHand.LeftWrist);
            }
            
            document.getElementById('loading').style.display = 'none';
        });

        // The MediaPipe initialization is done in the global scripts below
    </script>

    <!-- MediaPipe Scripts (loaded globally) -->
    <script src="cdn.jsdelivr.net" crossorigin="anonymous"></script>
    <script src="cdn.jsdelivr.net" crossorigin="anonymous"></script>

    <script>
        // --- INITIALIZE MEDIAPIPE ---
        const videoElement = document.querySelector('.input_video');
        
        const holistic = new Holistic({locateFile: (file) => {
            return `cdn.jsdelivr.net{file}`;
        }});

        holistic.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        // When MediaPipe has results, dispatch a custom event
        holistic.onResults((results) => {
            const event = new CustomEvent('mediapipe-results', { detail: results });
            window.dispatchEvent(event);
        });

        // Start the camera
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await holistic.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        camera.start();
    </script>
</body>
</html>
